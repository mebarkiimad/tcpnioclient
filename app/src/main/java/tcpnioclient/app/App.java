/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package tcpnioclient.app;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.schedulers.Schedulers;
import io.reactivex.rxjava3.subjects.PublishSubject;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.util.Random;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReference;

public class App {
    public static void main(String[] args) {

        PublishSubject<String> subject = PublishSubject.create();
       subject.subscribeOn(Schedulers.newThread());
       Thread t4 = new Thread(() -> {
           for (int i = 0;i<100;i++){
               subject.onNext(String.valueOf(i));
           }
       });
       t4.start();
        AsynchronousSocketChannel client = null;
         AtomicReference<ByteBuffer> writeBuffer = new AtomicReference<>(ByteBuffer.allocate(32));
        ByteBuffer readBuffer = ByteBuffer.allocate(32);
        try {
            client = AsynchronousSocketChannel.open();
            InetSocketAddress hostAddress = new InetSocketAddress("localhost", 1234);
            Future<Void> c = client.connect(hostAddress);
            c.get(500, TimeUnit.MILLISECONDS);
            if(c.isDone()){

                    AsynchronousSocketChannel finalClient = client;
                    Observable<String> observable = Observable.create(emitter -> {
                        for (int i = 0; i < 20; i++) {
                            Future<Integer> readResult = finalClient.read(readBuffer);
                            // do some computation
                            try {
                                readResult.get();
                            } catch (InterruptedException | ExecutionException e) {
                                System.out.println(e.getClass().getName());
                                e.printStackTrace();
                            }
                            String echo = new String(readBuffer.array()).trim();
                            emitter.onNext(echo.trim());
                            readBuffer.clear();
                        }
                    });
                    observable.subscribeOn(Schedulers.io()).observeOn(Schedulers.io()
                    ).subscribe(System.out::println);
                    Thread.sleep(5000);


                    Observable<String> observable1 = Observable.create(emitter -> {

                        for(int i =0;i<5;i++){
                            byte[] byteMsg = new String("CLIENT"+"\r\n").getBytes();
                            writeBuffer.set(ByteBuffer.wrap(byteMsg));
                            Future<Integer> writeResult = finalClient.write(writeBuffer.get());
                            try {
                            if(writeResult.isDone()) {
                                Integer result = writeResult.get();
                            }

                        } catch (InterruptedException | ExecutionException e) {

                        }
                            try {
                                Random r = new Random();
                                int low = 0;
                                int high =1000;
                                int result = r.nextInt(high-low) + low;
                                Thread.sleep(200);
                                emitter.onNext(String.valueOf(i));
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }}

                    });
                    observable1.subscribe(s -> System.out.println("Already Sent"+s));

            }
        } catch (IOException | ExecutionException | InterruptedException | TimeoutException e) {
            e.printStackTrace();
        }

    }
}
